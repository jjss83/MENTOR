<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mentor Train Monitor</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <style>
    :root {
      --bg: #0b0c0f;
      --glass: rgba(255, 255, 255, 0.06);
      --stroke: rgba(255, 255, 255, 0.12);
      --text: #e7e9ee;
      --muted: #9ba1b0;
      --accent: #7dd3fc;
      --success: #6ee7b7;
      --error: #f47272;
      --warning: #f6c263;
      --card-radius: 18px;
      --shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
      --embed-height: 360px;
      --log-height: 140px;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: "SF Pro Display", "Segoe UI Variable", "Helvetica Neue", sans-serif;
      color: var(--text);
      background: radial-gradient(circle at 20% 20%, #1d2433, transparent 35%),
                  radial-gradient(circle at 80% 0%, #132032, transparent 30%),
                  linear-gradient(145deg, #06070a, #0d1118 60%, #0f1724);
      letter-spacing: 0.01em;
    }
    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 32px 26px 48px;
    }
    header {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .top-line {
      display: flex;
      justify-content: space-between;
      gap: 18px;
      flex-wrap: wrap;
      align-items: flex-end;
    }
    .eyebrow {
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
      font-size: 11px;
    }
    h1 {
      margin: 6px 0 6px;
      font-size: 34px;
      font-weight: 700;
      color: #f4f6fb;
    }
    .subtitle {
      margin: 0;
      color: var(--muted);
      max-width: 560px;
      line-height: 1.4;
    }
    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .embed-card {
      background: var(--glass);
      border: 1px solid var(--stroke);
      border-radius: var(--card-radius);
      padding: 14px 16px 10px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
    }
    .embed-frame {
      width: 100%;
      height: var(--embed-height);
      border: 1px solid var(--stroke);
      border-radius: 12px;
      overflow: hidden;
    }
    .embed-frame iframe {
      width: 100%;
      height: 100%;
      border: 0;
      background: #0b0c0f;
    }
    .slider-wrap {
      background: var(--glass);
      border: 1px solid var(--stroke);
      padding: 10px 12px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      min-width: 240px;
      box-shadow: var(--shadow);
    }
    .slider-label {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 120px;
    }
    .slider-value {
      font-weight: 600;
      color: var(--text);
    }
    input[type="range"] {
      accent-color: #7dd3fc;
      width: 140px;
    }
    .input-wrap {
      background: var(--glass);
      border: 1px solid var(--stroke);
      padding: 10px 12px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 260px;
      box-shadow: var(--shadow);
    }
    label {
      font-size: 12px;
      color: var(--muted);
    }
    input {
      background: transparent;
      border: none;
      outline: none;
      color: var(--text);
      font-size: 14px;
      width: 100%;
    }
    button {
      background: linear-gradient(120deg, #8ec5ff, #7dd3fc);
      color: #0a0c10;
      border: none;
      border-radius: 12px;
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 12px 30px rgba(125, 211, 252, 0.25);
      transition: transform 120ms ease, box-shadow 120ms ease, opacity 120ms ease;
    }
    button.secondary {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      border: 1px solid var(--stroke);
      box-shadow: none;
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 36px rgba(125, 211, 252, 0.3);
    }
    button:active {
      transform: translateY(0);
      opacity: 0.92;
    }
    .icon-btn {
      padding: 8px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid var(--stroke);
      border-radius: 12px;
      box-shadow: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--text);
      min-width: 0;
      line-height: 0;
      transition: transform 120ms ease, border-color 120ms ease, background 120ms ease, opacity 120ms ease;
    }
    .icon-btn.danger {
      color: #f87171;
      border-color: rgba(248, 113, 113, 0.5);
      background: rgba(248, 113, 113, 0.08);
    }
    .icon-btn:hover { background: rgba(255, 255, 255, 0.12); border-color: var(--accent); transform: translateY(-1px); }
    .icon-btn.danger:hover { background: rgba(248, 113, 113, 0.16); border-color: rgba(248, 113, 113, 0.85); color: #fecdd3; }
    .icon-btn:active { transform: translateY(0); opacity: 0.9; }
    .icon-btn svg { width: 16px; height: 16px; }
    .icon-btn.spinning svg { animation: spin 0.8s linear infinite; }
    .icon-btn.error { border-color: var(--error); color: var(--error); }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    .status-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }
    .tile {
      background: var(--glass);
      border: 1px solid var(--stroke);
      border-radius: var(--card-radius);
      padding: 14px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
    }
    .health-dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      box-shadow: 0 0 0 6px rgba(110, 231, 183, 0.1);
      background: var(--success);
    }
    .health-dot.off {
      background: var(--error);
      box-shadow: 0 0 0 6px rgba(244, 114, 114, 0.1);
    }
    .health-dot.degraded {
      background: var(--warning);
      box-shadow: 0 0 0 6px rgba(246, 194, 99, 0.12);
    }
    .tile-title {
      font-size: 13px;
      color: var(--muted);
    }
    .tile-value {
      font-size: 18px;
      font-weight: 700;
    }
    .pill-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
      margin: 8px 0 4px;
    }
    .pill {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--stroke);
      border-radius: 14px;
      padding: 12px 14px;
      box-shadow: var(--shadow);
    }
    .pill-label { color: var(--muted); font-size: 12px; }
    .pill-value { font-size: 20px; font-weight: 700; }
    .process-card { gap: 10px; }
    .process-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 12px;
      align-items: flex-start;
    }
    .process-tables {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 12px;
    }
    .table-block {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--stroke);
      border-radius: 14px;
      padding: 12px;
      box-shadow: var(--shadow);
    }
    .table-head {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 8px;
    }
    .table-wrap {
      border: 1px solid var(--stroke);
      border-radius: 12px;
      overflow: hidden;
      background: rgba(255, 255, 255, 0.02);
    }
    .process-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    .process-table th,
    .process-table td {
      padding: 10px 12px;
      text-align: left;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }
    .process-table thead {
      background: rgba(255, 255, 255, 0.04);
      font-size: 12px;
      letter-spacing: 0.01em;
      color: var(--muted);
    }
    .process-table tbody tr:last-child td {
      border-bottom: none;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(255, 255, 255, 0.06);
      font-size: 12px;
    }
    .badge-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }
    .badge.success .badge-dot { background: var(--success); }
    .badge.alert .badge-dot { background: var(--error); }
    .badge.idle .badge-dot { background: #94a3b8; }
    .muted { color: var(--muted); }
    .micro-label { color: var(--muted); font-size: 12px; margin-top: 6px; }
    .chip-row { display: flex; flex-wrap: wrap; gap: 8px; }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 7px 12px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid var(--stroke);
      border-radius: 999px;
      font-size: 12px;
    }
    .chip.alert { border-color: var(--warning); color: var(--warning); }
    .action-row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
      margin-top: 4px;
    }
    .action-controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    select {
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid var(--stroke);
      border-radius: 10px;
      color: var(--text);
      padding: 10px 12px;
      min-width: 220px;
    }
    main {
      margin-top: 18px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .section-head {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 12px;
      flex-wrap: wrap;
    }
    .section-title { font-size: 18px; font-weight: 700; }
    .section-note { color: var(--muted); font-size: 13px; }
    .selection-note { color: var(--muted); font-size: 13px; display: flex; align-items: center; gap: 8px; }
    .selection-chip {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      font-size: 12px;
    }
    .clear-btn {
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid var(--stroke);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
    }
    .clear-btn:hover { opacity: 0.9; }
    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }
    .card {
      background: var(--glass);
      border: 1px solid var(--stroke);
      border-radius: var(--card-radius);
      padding: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .card.selected { border-color: var(--accent); box-shadow: 0 0 0 1px rgba(125, 211, 252, 0.4); }
    .card.collapsed { opacity: 0.82; }
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }
    .card-actions { display: inline-flex; align-items: center; gap: 8px; flex-wrap: wrap; justify-content: flex-end; }
    .run-id {
      font-weight: 700;
      font-size: 16px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .status-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid var(--stroke);
      font-size: 12px;
      text-transform: capitalize;
    }
    .status-dot {
      width: 9px;
      height: 9px;
      border-radius: 50%;
    }
    .status-running .status-dot { background: var(--accent); }
    .status-succeeded .status-dot { background: var(--success); }
    .status-failed .status-dot { background: var(--error); }
    .status-canceled .status-dot { background: var(--warning); }
    .status-stopped .status-dot { background: var(--muted); }
    .status-unknown .status-dot { background: #94a3b8; }
    .status-not-found .status-dot { background: #94a3b8; }
    .detail-textarea { cursor: default; user-select: text; }
    .detail-attributes {
      border: 1px solid var(--stroke);
      border-radius: 14px;
      padding: 14px;
      background: rgba(255, 255, 255, 0.02);
      font-family: "SF Mono", "JetBrains Mono", "Menlo", monospace;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      min-height: 110px;
    }
    .attr-chip {
      border-left: 4px solid rgba(125, 211, 252, 0.6);
      padding: 6px 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-height: 46px;
      background: transparent;
    }
    .attr-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
    }
    .attr-value {
      font-size: 13px;
      color: var(--text);
      word-break: break-word;
      white-space: pre-wrap;
    }
        .attr-empty {
          grid-column: 1 / -1;
          text-align: center;
          color: var(--muted);
          font-size: 13px;
          padding: 6px 0;
        }
    .attr-path { border-color: rgba(125, 211, 252, 0.7); }
    .attr-status { border-color: rgba(110, 231, 183, 0.7); }
    .attr-warning { border-color: rgba(246, 194, 99, 0.8); }
    .attr-log { border-color: rgba(148, 163, 184, 0.7); }
    .attr-flag { border-color: rgba(125, 86, 252, 0.7); }
    .attr-config { border-color: rgba(244, 114, 182, 0.7); }
    .label { color: var(--muted); font-size: 12px; margin-bottom: 2px; }
    @media (max-width: 640px) {
      .detail-attributes { grid-template-columns: repeat(1, minmax(0, 1fr)); }
    }
    .resume-inline {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid var(--stroke);
      background: rgba(255, 255, 255, 0.06);
    }
    .resume-inline input[type="checkbox"] { width: 16px; height: 16px; accent-color: var(--accent); }
    .log {
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid var(--stroke);
      border-radius: 12px;
      padding: 10px 12px;
      font-family: "SF Mono", "JetBrains Mono", "Menlo", monospace;
      color: #dfe5f5;
      font-size: 12px;
      white-space: pre-wrap;
      max-height: var(--log-height);
      overflow: auto;
    }
    .log-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 6px;
    }
    .log-actions button {
      padding: 8px 12px;
      border-radius: 10px;
    }
    .empty {
      text-align: center;
      padding: 18px;
      color: var(--muted);
      border: 1px dashed var(--stroke);
      border-radius: var(--card-radius);
      background: rgba(255, 255, 255, 0.02);
    }
    @media (max-width: 640px) {
      .page { padding: 22px 18px 32px; }
      h1 { font-size: 28px; }
      .card { padding: 14px; }
      .details-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div class="top-line">
        <div>
          <div class="eyebrow">Mentor</div>
          <h1>Train Monitor</h1>
          <p class="subtitle">MENTOR keeps tabs on your training runs, surfacing health, counts, and live log tails in one glance.</p>
        </div>
        <div class="controls">
          <div class="input-wrap">
            <label for="api-base">API</label>
            <input id="api-base" type="text" spellcheck="false" aria-label="API base" />
          </div>
          <div class="slider-wrap" aria-label="Refresh cadence">
            <div class="slider-label">
              <div class="label">Refresh cadence</div>
              <div class="slider-value"><span id="refresh-seconds">5</span>s</div>
            </div>
            <input id="refresh-slider" type="range" min="1" max="10" step="1" value="5" aria-label="Refresh cadence (seconds)" />
          </div>
          <div class="slider-wrap" aria-label="TensorBoard height">
            <div class="slider-label">
              <div class="label">TensorBoard height</div>
              <div class="slider-value"><span id="embed-height-value">360</span>px</div>
            </div>
            <input id="embed-height-slider" type="range" min="240" max="800" step="20" value="360" aria-label="TensorBoard height (px)" />
          </div>
          <div class="slider-wrap" aria-label="Run log height">
            <div class="slider-label">
              <div class="label">Run log height</div>
              <div class="slider-value"><span id="log-height-value">140</span>px</div>
            </div>
            <input id="log-height-slider" type="range" min="100" max="400" step="20" value="140" aria-label="Run log height (px)" />
          </div>
          <button id="set-api">Set API</button>
          <button id="refresh" class="secondary">Refresh now</button>
        </div>
      </div>
      <div class="status-row">
        <div class="tile">
          <div id="health-dot" class="health-dot"></div>
          <div>
            <div class="tile-title">API health</div>
            <div id="health-label" class="tile-value">Checking...</div>
          </div>
        </div>
        <div class="tile">
          <div>
            <div class="tile-title">Auto refresh</div>
            <div class="tile-value" id="refresh-label">Every 5s</div>
          </div>
        </div>
        <div class="tile">
          <div>
            <div class="tile-title">Last updated</div>
            <div class="tile-value" id="updated-label">-</div>
          </div>
        </div>
      </div>
    </header>

    <main>
      <section id="tensorboard-embed" class="embed-card" hidden>
        <div class="section-head">
          <div class="section-title">TensorBoard - Environment / Cumulative Reward</div>
          <div class="section-note" id="tensorboard-note"></div>
          <button id="start-tensorboard" class="secondary">Start TensorBoard</button>
        </div>
        <div class="embed-frame">
          <iframe id="tensorboard-frame" title="TensorBoard Environment Cumulative Reward"></iframe>
        </div>
      </section>

      <section>
        <div class="pill-row">
          <div class="pill">
            <div class="pill-label">Running</div>
            <div class="pill-value" id="running-count">0</div>
          </div>
          <div class="pill">
            <div class="pill-label">Completed</div>
            <div class="pill-value" id="completed-count">0</div>
          </div>
          <div class="pill">
            <div class="pill-label">Failures</div>
            <div class="pill-value" id="failed-count">0</div>
          </div>
        </div>
      </section>

      <section class="card process-card">
        <div class="section-head">
          <div class="section-title">Process watch</div>
          <div class="section-note" id="process-note">Waiting for first update...</div>
        </div>
        <div class="process-tables">
          <div class="table-block">
            <div class="table-head">
              <div class="table-title">ML-Agents learn</div>
              <div class="micro-label" id="mlagents-note">Awaiting data...</div>
            </div>
            <div class="table-wrap">
              <table class="process-table">
                <thead>
                  <tr>
                    <th>Executable</th>
                    <th>Status</th>
                    <th>Running</th>
                  </tr>
                </thead>
                <tbody id="mlagents-table-body">
                  <tr><td colspan="3" class="muted">Waiting for process info...</td></tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="table-block">
            <div class="table-head">
              <div class="table-title">Environment executables</div>
              <div class="micro-label" id="env-note">Discovering env executables from results folders.</div>
            </div>
            <div class="table-wrap">
              <table class="process-table">
                <thead>
                  <tr>
                    <th>Executable</th>
                    <th>Status</th>
                    <th>Running</th>
                  </tr>
                </thead>
                <tbody id="env-table-body">
                  <tr><td colspan="3" class="muted">Waiting for process info...</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <div class="action-row">
          <div class="pill-label">Kill processes</div>
          <div class="action-controls">
            <select id="kill-select" aria-label="Executable to kill">
              <option value="">Select executable</option>
            </select>
            <button id="kill-btn" class="secondary">Kill all</button>
          </div>
          <div class="micro-label" id="kill-note">Choose an executable to terminate its running processes.</div>
        </div>
      </section>

      <section>
        <div class="section-head">
          <div class="section-title">Runs</div>
          <div class="section-note" id="runs-note"></div>
          <div class="selection-note">
            <span class="selection-chip" id="selection-chip">0 of 0 showing details</span>
            <button class="clear-btn" id="clear-selection">Show all details</button>
          </div>
        </div>
        <div id="run-grid" class="grid"></div>
      </section>
    </main>
  </div>

  <script>
    (() => {
      const state = {
        apiBase: localStorage.getItem('mentorApiBase') || 'http://localhost:5113',
        refreshMs: 5000,
        refreshHandle: null,
        tickerHandle: null,
        nextRefreshAt: null,
        embedHeight: 360,
        logHeight: 140,
        knownEnvExecutables: [],
        hiddenRuns: new Set(),
        lastRuns: [],
        logCache: new Map(),
        tensorboardUrl: null,
        forceTensorboardReload: false,
      };

      const defaultTensorboardUrl = 'http://localhost:6006/';

      const storedRefreshMs = Number(localStorage.getItem('mentorRefreshMs'));
      if (storedRefreshMs >= 1000 && storedRefreshMs <= 10000) {
        state.refreshMs = storedRefreshMs;
      }

      const storedEmbedHeight = Number(localStorage.getItem('mentorEmbedHeight'));
      if (storedEmbedHeight >= 240 && storedEmbedHeight <= 800) {
        state.embedHeight = storedEmbedHeight;
      }

      const storedLogHeight = Number(localStorage.getItem('mentorLogHeight'));
      if (storedLogHeight >= 100 && storedLogHeight <= 400) {
        state.logHeight = storedLogHeight;
      }

      const el = {
        apiInput: document.getElementById('api-base'),
        healthDot: document.getElementById('health-dot'),
        healthLabel: document.getElementById('health-label'),
        refreshLabel: document.getElementById('refresh-label'),
        updatedLabel: document.getElementById('updated-label'),
        refreshSlider: document.getElementById('refresh-slider'),
        refreshSeconds: document.getElementById('refresh-seconds'),
        embedHeightSlider: document.getElementById('embed-height-slider'),
        embedHeightValue: document.getElementById('embed-height-value'),
        logHeightSlider: document.getElementById('log-height-slider'),
        logHeightValue: document.getElementById('log-height-value'),
        tbSection: document.getElementById('tensorboard-embed'),
        tbFrame: document.getElementById('tensorboard-frame'),
        tbNote: document.getElementById('tensorboard-note'),
        tbStart: document.getElementById('start-tensorboard'),
        runGrid: document.getElementById('run-grid'),
        runsNote: document.getElementById('runs-note'),
        selectionChip: document.getElementById('selection-chip'),
        clearSelection: document.getElementById('clear-selection'),
        runningCount: document.getElementById('running-count'),
        completedCount: document.getElementById('completed-count'),
        failedCount: document.getElementById('failed-count'),
        processNote: document.getElementById('process-note'),
        mlagentsNote: document.getElementById('mlagents-note'),
        mlagentsTableBody: document.getElementById('mlagents-table-body'),
        envTableBody: document.getElementById('env-table-body'),
        envNote: document.getElementById('env-note'),
        killSelect: document.getElementById('kill-select'),
        killBtn: document.getElementById('kill-btn'),
        killNote: document.getElementById('kill-note'),
        refreshBtn: document.getElementById('refresh'),
        setApiBtn: document.getElementById('set-api'),
      };

      const pick = (obj, key) => obj?.[key] ?? obj?.[key.charAt(0).toUpperCase() + key.slice(1)];

      el.apiInput.value = state.apiBase;
      const initialSeconds = state.refreshMs / 1000;
      el.refreshLabel.textContent = `Every ${initialSeconds}s`;
      el.refreshSlider.value = initialSeconds;
      el.refreshSeconds.textContent = initialSeconds;
      el.embedHeightSlider.value = state.embedHeight;
      el.embedHeightValue.textContent = state.embedHeight;
      el.logHeightSlider.value = state.logHeight;
      el.logHeightValue.textContent = state.logHeight;
      document.documentElement.style.setProperty('--embed-height', `${state.embedHeight}px`);
      document.documentElement.style.setProperty('--log-height', `${state.logHeight}px`);

      function setApiBase(value) {
        if (!value) return;
        state.apiBase = value.trim().replace(/\/$/, '');
        localStorage.setItem('mentorApiBase', state.apiBase);
        state.logCache.clear();
      }

      function setRefreshMs(seconds) {
        const fallback = state.refreshMs / 1000;
        const secs = Math.min(10, Math.max(1, Number(seconds) || fallback));
        state.refreshMs = secs * 1000;
        localStorage.setItem('mentorRefreshMs', state.refreshMs);
        el.refreshSeconds.textContent = secs;
        el.refreshSlider.value = secs;
        scheduleNextRefresh();
      }

      function setEmbedHeight(px) {
        const fallback = state.embedHeight;
        const value = Math.min(800, Math.max(240, Number(px) || fallback));
        state.embedHeight = value;
        localStorage.setItem('mentorEmbedHeight', value);
        el.embedHeightSlider.value = value;
        el.embedHeightValue.textContent = value;
        document.documentElement.style.setProperty('--embed-height', `${value}px`);
      }

      function setLogHeight(px) {
        const fallback = state.logHeight;
        const value = Math.min(400, Math.max(100, Number(px) || fallback));
        state.logHeight = value;
        localStorage.setItem('mentorLogHeight', value);
        el.logHeightSlider.value = value;
        el.logHeightValue.textContent = value;
        document.documentElement.style.setProperty('--log-height', `${value}px`);
      }

      function deriveLogPath(run) {
        const direct = pick(run, 'logPath');
        if (direct) return direct;

        const statusPath = pick(run, 'trainingStatusPath');
        if (statusPath) {
          const base = statusPath.replace(/training_status\.json$/i, '').replace(/[\\/]+$/, '');
          if (base) {
            return `${base}/mentor-api.log`;
          }
        }

        const resultsDir = pick(run, 'resultsDirectory');
        const runId = pick(run, 'runId');
        if (resultsDir && runId) {
          return [resultsDir, runId, 'run_logs', 'mentor-api.log'].join('/');
        }

        return null;
      }

      function toFileUrl(path) {
        if (!path) return null;
        const normalized = path.replace(/\\/g, '/');
        if (/^[a-zA-Z]:\//.test(normalized)) {
          return `file:///${encodeURI(normalized)}`;
        }
        if (normalized.startsWith('/')) {
          return `file://${encodeURI(normalized)}`;
        }
        return null;
      }

      function getCachedLog(runId) {
        if (!runId) return null;
        return state.logCache.get(runId) || null;
      }

      function findRunById(runId) {
        if (!runId) return null;
        return state.lastRuns.find(r => pick(r, 'runId') === runId) || null;
      }

      function getLogText(runId, run) {
        const cache = getCachedLog(runId);
        if (cache?.error) {
          return `Log unavailable: ${cache.error}`;
        }
        if (cache?.content) {
          return cache.content;
        }
        const tail = pick(run, 'logTail');
        if (Array.isArray(tail) && tail.length) {
          return tail.filter(Boolean).join('\n');
        }
        return 'Waiting for log output...';
      }

      function applyLogCacheToView() {
        document.querySelectorAll('.log[data-run-id]').forEach(el => {
          const runId = el.dataset.runId;
          if (!runId) return;
          const cache = getCachedLog(runId);
          const run = findRunById(runId);
          let text = cache?.error ? `Log unavailable: ${cache.error}` : (cache?.content || '');
          if (!text && run) {
            const tail = pick(run, 'logTail');
            if (Array.isArray(tail) && tail.length) {
              text = tail.filter(Boolean).join('\n');
            }
          }
          el.textContent = text || 'Waiting for log output...';
          el.scrollTop = el.scrollHeight;
        });
      }

      async function fetchLogSegment(run) {
        const runId = pick(run, 'runId');
        if (!runId) return;
        const resultsDir = pick(run, 'resultsDirectory');
        const cached = getCachedLog(runId);
        const params = new URLSearchParams();
        if (resultsDir) params.set('resultsDir', resultsDir);
        if (cached?.to) params.set('from', cached.to);
        const query = params.toString();
        const url = `${state.apiBase}/train/log/${encodeURIComponent(runId)}${query ? `?${query}` : ''}`;
        const data = await fetchJson(url);
        const from = Number(data?.from ?? 0);
        const to = Number(data?.to ?? from);
        const size = Number(data?.size ?? to);
        const content = typeof data?.content === 'string' ? data.content : '';
        const reset = !cached || from === 0 || from < (cached.to ?? 0);
        const mergedContent = reset ? content : `${cached.content}${content}`;
        const entry = {
          content: mergedContent,
          to: Number.isFinite(to) ? to : (reset ? mergedContent.length : cached?.to ?? 0),
          size: Number.isFinite(size) ? size : (cached?.size ?? 0),
          eof: !!data?.eof,
          logPath: data?.logPath || cached?.logPath || deriveLogPath(run),
          error: null,
        };
        state.logCache.set(runId, entry);
      }

      async function refreshLogs(runs) {
        const list = Array.isArray(runs) ? runs : [];
        const validIds = new Set(list.map(r => pick(r, 'runId')).filter(Boolean));
        Array.from(state.logCache.keys()).forEach(key => {
          if (!validIds.has(key)) {
            state.logCache.delete(key);
          }
        });
        const tasks = list.map(run => fetchLogSegment(run).catch(err => {
          const runId = pick(run, 'runId');
          if (!runId) return;
          const existing = getCachedLog(runId) || {};
          state.logCache.set(runId, {
            ...existing,
            content: existing.content || '',
            to: existing.to || 0,
            size: existing.size || 0,
            eof: existing.eof || false,
            logPath: existing.logPath || deriveLogPath(run),
            error: err?.message || 'Failed to load log.',
          });
        }));
        if (tasks.length) {
          await Promise.allSettled(tasks);
        }
        applyLogCacheToView();
      }

      async function fetchJson(url) {
        const response = await fetch(url, { headers: { Accept: 'application/json' } });
        if (!response.ok) {
          const text = await response.text();
          throw new Error(text || `Request failed (${response.status})`);
        }
        return response.json();
      }

      async function postJson(url, body) {
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Accept: 'application/json' },
          body: JSON.stringify(body || {}),
        });
        const text = await response.text();
        if (!response.ok) {
          let message = text || `Request failed (${response.status})`;
          try {
            const parsed = JSON.parse(text);
            message = parsed?.error || parsed?.message || message;
          } catch { /* ignore parse errors */ }
          throw new Error(message);
        }
        if (!text) return {};
        try {
          return JSON.parse(text);
        } catch {
          return {};
        }
      }

      async function updateHealth() {
        try {
          const data = await fetchJson(`${state.apiBase}/health`);
          const healthy = data && data.status === 'ok';
          renderHealth(healthy, healthy ? 'Operational' : 'Degraded');
        } catch (err) {
          renderHealth(false, 'Offline');
          el.runsNote.textContent = 'API unreachable. Check the base URL or start mentor-api.';
          console.error(err);
        }
      }

      function renderHealth(isUp, label) {
        el.healthLabel.textContent = label;
        el.healthDot.classList.remove('off', 'degraded');
        if (!isUp) {
          el.healthDot.classList.add('off');
        }
      }

      function updateRefreshLabel() {
        if (!state.nextRefreshAt) {
          el.refreshLabel.textContent = `Every ${state.refreshMs / 1000}s`;
          return;
        }
        const remainingMs = Math.max(0, state.nextRefreshAt - Date.now());
        const seconds = Math.ceil(remainingMs / 1000);
        el.refreshLabel.textContent = `Next refresh in ${seconds}s`;
      }

      function startTicker() {
        if (state.tickerHandle) {
          clearInterval(state.tickerHandle);
        }
        updateRefreshLabel();
        state.tickerHandle = setInterval(updateRefreshLabel, 500);
      }

      function statusClass(status) {
        const normalized = (status || '').toLowerCase();
        if (normalized === 'running') return 'status-running';
        if (normalized === 'stopping') return 'status-canceled';
        if (normalized === 'stopped') return 'status-stopped';
        if (normalized === 'succeeded' || normalized === 'success' || normalized === 'completed') return 'status-succeeded';
        if (normalized === 'failed' || normalized === 'failure') return 'status-failed';
        if (normalized === 'canceled' || normalized === 'cancelled') return 'status-canceled';
        if (normalized === 'unknown') return 'status-unknown';
        return 'status-not-found';
      }

      function renderRuns(runs, errorMessage) {
        el.runGrid.innerHTML = '';
        if (errorMessage) {
          const div = document.createElement('div');
          div.className = 'empty';
          div.textContent = errorMessage;
          el.runGrid.appendChild(div);
          setCounts([]);
          renderTensorboard([]);
          state.hiddenRuns.clear();
          state.lastRuns = [];
          updateSelectionChip();
          return;
        }
        const list = Array.isArray(runs) ? runs.slice() : [];
        state.lastRuns = list;
        if (!list.length) {
          const div = document.createElement('div');
          div.className = 'empty';
          div.textContent = 'No runs yet. Kick off training to see status here.';
          el.runGrid.appendChild(div);
          setCounts([]);
          renderTensorboard([]);
          state.hiddenRuns.clear();
          updateSelectionChip();
          return;
        }
        list.sort((a, b) => Number(pick(a, 'completed')) - Number(pick(b, 'completed')));
        pruneSelection(list.map(r => pick(r, 'runId')).filter(Boolean));
        list.forEach(run => el.runGrid.appendChild(buildCard(run)));

        setCounts(list);
        el.runsNote.textContent = `${list.length} run${list.length === 1 ? '' : 's'} tracked`;
        renderTensorboard(list, state.forceTensorboardReload);
        updateSelectionChip();
        applyLogCacheToView();
      }

      function buildCard(run) {
        const card = document.createElement('div');
        card.className = 'card';
        const header = document.createElement('div');
        header.className = 'card-header';
        const runId = pick(run, 'runId') || 'Unknown run';
        const cachedLog = getCachedLog(runId);
        const runParams = pick(run, 'parameters') || {};
        const resumeFlag = pick(run, 'resumeOnStart') ?? pick(runParams, 'resumeOnStart');
        const isCompleted = !!pick(run, 'completed');
        const logPath = cachedLog?.logPath || deriveLogPath(run);
        const logUrl = toFileUrl(logPath) ?? logPath;
        const selection = document.createElement('input');
        selection.type = 'checkbox';
        selection.ariaLabel = `Show details for ${runId}`;
        const detailsVisible = !state.hiddenRuns.has(runId);
        selection.checked = detailsVisible;
        selection.addEventListener('click', (event) => {
          event.stopPropagation();
          toggleRunSelection(runId, selection.checked);
        });
        const id = document.createElement('div');
        id.className = 'run-id';
        id.textContent = runId;
        const toggleLabel = document.createElement('div');
        toggleLabel.className = 'pill-label';
        toggleLabel.textContent = 'Details';
        const chip = document.createElement('div');
        const statusText = pick(run, 'status');
        const sClass = statusClass(statusText);
        chip.className = `status-chip ${sClass}`;
        const dot = document.createElement('span');
        dot.className = 'status-dot';
        const label = document.createElement('span');
        label.textContent = statusText || 'unknown';
        chip.append(dot, label);
        const selectionWrap = document.createElement('div');
        selectionWrap.style.display = 'flex';
        selectionWrap.style.alignItems = 'center';
        selectionWrap.style.gap = '6px';
        selectionWrap.append(selection, toggleLabel);
        const archiveBtn = createArchiveButton(runId);
        const deleteBtn = createDeleteButton(runId, run);
        const stopBtn = createStopButton(runId, statusText, run);
        const resumeBtn = createResumeButton(runId, statusText, isCompleted, run);
        const resumeInline = document.createElement('div');
        resumeInline.className = 'resume-inline';
        const resumeToggle = document.createElement('input');
        resumeToggle.type = 'checkbox';
        resumeToggle.checked = isCompleted ? false : !!resumeFlag;
        resumeToggle.disabled = isCompleted;
        resumeToggle.addEventListener('click', (event) => event.stopPropagation());
        const resumeLabel = document.createElement('div');
        resumeLabel.className = 'pill-label';
        resumeLabel.textContent = 'Resume on API start';
        const resumeNote = document.createElement('div');
        resumeNote.className = 'pill-label';
        const setResumeNote = (text) => { resumeNote.textContent = text; };
        if (isCompleted) {
          setResumeNote('Completed runs cannot auto-resume');
        } else {
          setResumeNote(resumeToggle.checked ? 'Will resume automatically' : 'Disabled by default');
        }
        resumeToggle.addEventListener('change', async (event) => {
          if (isCompleted) {
            event.preventDefault();
            return;
          }
          const desired = event.target.checked;
          resumeToggle.disabled = true;
          setResumeNote(desired ? 'Marking...' : 'Updating...');
          try {
            await postJson(`${state.apiBase}/train/resume-flag`, { runId, resumeOnStart: desired, resultsDir: pick(run, 'resultsDirectory') });
            setResumeNote(desired ? 'Will resume automatically' : 'Will not auto-resume');
            await refreshAll();
          } catch (err) {
            console.error(err);
            resumeToggle.checked = !desired;
            setResumeNote(err?.message || 'Failed to update');
          } finally {
            resumeToggle.disabled = false;
          }
        });
        resumeInline.append(resumeToggle, resumeLabel, resumeNote);

        const actions = document.createElement('div');
        actions.className = 'card-actions';
        if (stopBtn) actions.append(stopBtn);
        if (resumeBtn) actions.append(resumeBtn);
        actions.append(resumeInline, archiveBtn, deleteBtn, chip);
        header.append(selectionWrap, id, actions);

        const log = document.createElement('div');
        log.className = 'log';
        if (runId) {
          log.dataset.runId = runId;
        }
        log.textContent = getLogText(runId, run);
        const logActions = document.createElement('div');
        logActions.className = 'log-actions';
        const openLogBtn = document.createElement('button');
        openLogBtn.type = 'button';
        openLogBtn.className = 'secondary';
        openLogBtn.textContent = 'Open full log';
        openLogBtn.title = logPath || 'Log path unavailable';
        openLogBtn.disabled = !logUrl;
        openLogBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          if (logUrl) {
            window.open(logUrl, '_blank', 'noopener,noreferrer');
          } else {
            alert('Log path unavailable for this run.');
          }
        });
        logActions.append(openLogBtn);

        const detailsWrap = document.createElement('div');
        detailsWrap.className = 'card-details';
        const attributeArea = buildAttributeArea(run, runParams, logPath);
        detailsWrap.append(attributeArea, log, logActions);

        detailsWrap.hidden = !detailsVisible;
        card.append(header, detailsWrap);
        if (!detailsVisible) {
          card.classList.add('collapsed');
        } else {
          card.classList.add('selected');
        }

        return card;
      }

      function createStopButton(runId, statusText, run) {
        const normalized = (statusText || '').toLowerCase();
        if (normalized !== 'running') return null;
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'icon-btn secondary';
        btn.title = `Stop ${runId} for resume`;
        btn.textContent = 'Stop';
        btn.addEventListener('click', async (event) => {
          event.stopPropagation();
          await stopRun(runId, btn, pick(run, 'resultsDirectory'));
        });
        return btn;
      }

      function createResumeButton(runId, statusText, isCompleted, run) {
        const normalized = (statusText || '').toLowerCase();
        const canResume = !isCompleted && normalized !== 'running' && normalized !== 'stopping';
        if (!canResume) return null;
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'icon-btn';
        btn.title = `Resume ${runId}`;
        btn.textContent = 'Resume';
        btn.addEventListener('click', async (event) => {
          event.stopPropagation();
          await resumeRun(runId, btn, pick(run, 'resultsDirectory'));
        });
        return btn;
      }

      function createArchiveButton(runId) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'icon-btn';
        btn.title = `Archive ${runId}`;
        btn.innerHTML = `<svg viewBox="0 0 20 20" fill="none" aria-hidden="true"><path fill="currentColor" d="M4.25 6.5c-.966 0-1.75.784-1.75 1.75v7a1.75 1.75 0 0 0 1.75 1.75h11.5A1.75 1.75 0 0 0 17.5 15.25v-7c0-.966-.784-1.75-1.75-1.75H4.25Zm-.25 1.75c0-.138.112-.25.25-.25h11.5c.138 0 .25.112.25.25v7c0 .138-.112.25-.25.25H4.25a.25.25 0 0 1-.25-.25v-7Zm9.86-3.5-1.04-2.306A.75.75 0 0 0 12.109 2H7.891a.75.75 0 0 0-.671.394L6.18 4.75H4.75a.75.75 0 0 0 0 1.5h10.5a.75.75 0 0 0 0-1.5h-1.39ZM8.55 3.5h2.9l.45 1H8.1l.45-1Zm2.81 4.29a.75.75 0 0 0-1.06 0l-.8.8-.8-.8a.75.75 0 1 0-1.06 1.06l.8.8-.8.8a.75.75 0 1 0 1.06 1.06l.8-.8.8.8a.75.75 0 0 0 1.06-1.06l-.8-.8.8-.8a.75.75 0 0 0 0-1.06Z"/></svg>`;
        btn.addEventListener('click', async (event) => {
          event.stopPropagation();
          await archiveRun(runId, btn);
        });
        return btn;
      }

      function createDeleteButton(runId, run) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'icon-btn danger';
        btn.title = `Delete ${runId}`;
        btn.innerHTML = `<svg viewBox="0 0 20 20" fill="none" aria-hidden="true"><path fill="currentColor" d="M7.75 3.5h4.5a.75.75 0 0 0-.75-.75h-3a.75.75 0 0 0-.75.75Zm-2 .5a2.25 2.25 0 0 1 2.25-2.25h4a2.25 2.25 0 0 1 2.25 2.25h2.25a.75.75 0 0 1 0 1.5h-.346l-.63 9.607A2.25 2.25 0 0 1 12.293 17H7.707a2.25 2.25 0 0 1-2.232-2.393L4.845 5.5H4.25a.75.75 0 0 1 0-1.5H5.75Zm1.34 2a.75.75 0 0 1 .806.69l.5 6.5a.75.75 0 0 1-1.493.116l-.5-6.5a.75.75 0 0 1 .687-.806Zm6.508.806a.75.75 0 0 0-1.494-.116l-.5 6.5a.75.75 0 0 0 1.493.116l.5-6.5Z"/></svg>`;
        btn.addEventListener('click', async (event) => {
          event.stopPropagation();
          await deleteRun(runId, btn, pick(run, 'resultsDirectory'));
        });
        return btn;
      }

      function formatFlag(value, truthyLabel = 'Yes', falsyLabel = 'No') {
        if (value === true) return truthyLabel;
        if (value === false) return falsyLabel;
        return null;
      }

      function hasContent(value) {
        if (value === null || value === undefined) return false;
        if (typeof value === 'string') {
          return value.trim().length > 0;
        }
        return true;
      }

      function buildAttributeArea(run, runParams, logPath) {
        const list = [
          { label: 'Results', value: pick(run, 'resultsDirectory'), kind: 'path' },
          { label: 'Training status', value: pick(run, 'trainingStatusPath'), kind: 'path' },
          { label: 'TensorBoard URL', value: pick(run, 'tensorboardUrl'), kind: 'path' },
          { label: 'Log path', value: logPath, kind: 'log' },
          { label: 'Exit code', value: pick(run, 'exitCode'), kind: 'status' },
          { label: 'Env path', value: pick(runParams, 'envPath'), kind: 'path' },
          { label: 'Config', value: pick(runParams, 'configPath'), kind: 'config' },
          { label: 'Conda env', value: pick(runParams, 'condaEnv'), kind: 'config' },
          { label: 'Base port', value: pick(runParams, 'basePort'), kind: 'status' },
          { label: 'Graphics', value: formatFlag(pick(runParams, 'noGraphics'), 'No graphics', 'Graphics enabled'), kind: 'flag' },
          { label: 'Env executable', value: formatFlag(pick(runParams, 'hasEnvExecutable'), 'Yes', 'No'), kind: 'flag' },
          { label: 'Skip conda', value: formatFlag(pick(runParams, 'skipConda'), 'Skip', 'Use conda'), kind: 'flag' },
          { label: 'Launch TensorBoard', value: formatFlag(pick(runParams, 'tensorboard'), 'Yes', 'No'), kind: 'flag' },
          { label: 'Message', value: pick(run, 'message'), kind: 'warning' }
        ];
        const area = document.createElement('div');
        area.className = 'detail-attributes detail-textarea';
        area.setAttribute('role', 'textbox');
        area.setAttribute('aria-readonly', 'true');
        list.forEach(item => {
          if (!hasContent(item.value)) return;
          area.append(createAttrChip(item));
        });
        if (!area.childElementCount) {
          const empty = document.createElement('div');
          empty.className = 'attr-empty';
          empty.textContent = 'No run metadata available.';
          area.append(empty);
        }
        return area;
      }

      function createAttrChip(attr) {
        const chip = document.createElement('div');
        chip.className = `attr-chip attr-${attr.kind || 'log'}`;
        const label = document.createElement('div');
        label.className = 'attr-label';
        label.textContent = attr.label;
        const value = document.createElement('div');
        value.className = 'attr-value';
        const textValue = typeof attr.value === 'number' ? String(attr.value) : String(attr.value);
        value.textContent = textValue;
        chip.append(label, value);
        return chip;
      }

      function toggleRunSelection(runId, selected) {
        if (!runId) return;
        if (selected) {
          state.hiddenRuns.delete(runId);
        } else {
          state.hiddenRuns.add(runId);
        }
        updateSelectionChip();
        document.querySelectorAll('.card').forEach(card => {
          const title = card.querySelector('.run-id')?.textContent;
          if (title === runId) {
            const details = card.querySelector('.card-details');
            if (details) {
              details.hidden = !selected;
            }
            card.classList.toggle('selected', selected);
            card.classList.toggle('collapsed', !selected);
          }
        });
      }

      async function stopRun(runId, button, resultsDir) {
        if (!runId) return;
        const original = button?.textContent;
        if (button) {
          button.disabled = true;
          button.classList.add('spinning');
          button.textContent = 'Stopping...';
        }
        try {
          const payload = { runId };
          if (resultsDir) payload.resultsDir = resultsDir;
          const data = await postJson(`${state.apiBase}/train/stop`, payload);
          el.runsNote.textContent = pick(data, 'message') || `Stop requested for ${runId}.`;
          await refreshAll();
        } catch (err) {
          console.error(err);
          el.runsNote.textContent = err?.message || 'Failed to stop run.';
          if (button) {
            button.classList.add('error');
            setTimeout(() => button.classList.remove('error'), 1400);
          }
        } finally {
          if (button) {
            button.disabled = false;
            button.classList.remove('spinning');
            if (original) button.textContent = original;
          }
        }
      }

      async function resumeRun(runId, button, resultsDir) {
        if (!runId) return;
        const original = button?.textContent;
        if (button) {
          button.disabled = true;
          button.classList.add('spinning');
          button.textContent = 'Resuming...';
        }
        try {
          const payload = { runId };
          if (resultsDir) payload.resultsDir = resultsDir;
          const data = await postJson(`${state.apiBase}/train/resume`, payload);
          el.runsNote.textContent = pick(data, 'message') || `Resuming ${runId}...`;
          await refreshAll();
        } catch (err) {
          console.error(err);
          el.runsNote.textContent = err?.message || 'Failed to resume run.';
          if (button) {
            button.classList.add('error');
            setTimeout(() => button.classList.remove('error'), 1400);
          }
        } finally {
          if (button) {
            button.disabled = false;
            button.classList.remove('spinning');
            if (original) button.textContent = original;
          }
        }
      }

      async function archiveRun(runId, button) {
        if (!runId) return;
        if (button) {
          button.disabled = true;
          button.classList.add('spinning');
        }
        try {
          await postJson(`${state.apiBase}/train/archive`, { runId });
          state.lastRuns = state.lastRuns.filter(r => pick(r, 'runId') !== runId);
          renderRuns(state.lastRuns);
        } catch (err) {
          console.error(err);
          const message = (err?.message || 'Failed to archive run.').trim();
          el.runsNote.textContent = message;
          if (button) {
            button.classList.add('error');
            setTimeout(() => button.classList.remove('error'), 1400);
          }
        } finally {
          if (button) {
            button.disabled = false;
            button.classList.remove('spinning');
          }
        }
      }

      async function deleteRun(runId, button, resultsDir) {
        if (!runId) return;
        const confirmation = window.confirm(`Delete run '${runId}'? This will stop training (if running) and permanently remove its files.`);
        if (!confirmation) {
          el.runsNote.textContent = 'Delete canceled.';
          return;
        }
        const originalHtml = button?.innerHTML;
        if (button) {
          button.disabled = true;
          button.classList.add('spinning');
        }
        try {
          const payload = { runId, confirm: true };
          if (resultsDir) payload.resultsDir = resultsDir;
          const result = await postJson(`${state.apiBase}/train/delete`, payload);
          const message = pick(result, 'message') || `Deleted ${runId}.`;
          el.runsNote.textContent = message;
          await refreshAll();
        } catch (err) {
          console.error(err);
          const message = (err?.message || 'Failed to delete run.').trim();
          el.runsNote.textContent = message;
          if (button) {
            button.classList.add('error');
            setTimeout(() => button.classList.remove('error'), 1400);
          }
        } finally {
          if (button) {
            button.disabled = false;
            button.classList.remove('spinning');
            if (originalHtml) button.innerHTML = originalHtml;
          }
        }
      }

      function renderTensorboard(runs, forceReload = false) {
        const list = Array.isArray(runs) ? runs : [];
        const withTb = list.find(r => pick(r, 'tensorboardUrl'));
        const url = withTb ? pick(withTb, 'tensorboardUrl') : defaultTensorboardUrl;
        const note = withTb ? `From run ${pick(withTb, 'runId') || 'unknown'}` : 'Default (localhost:6006)';
        if (!url) {
          el.tbSection.hidden = true;
          el.tbFrame.removeAttribute('src');
          state.tensorboardUrl = null;
          return;
        }
        const current = el.tbFrame.getAttribute('src');
        const shouldReload = forceReload || current !== url;
        if (shouldReload) {
          if (current === url) {
            el.tbFrame.setAttribute('src', '');
          }
          el.tbFrame.setAttribute('src', url);
        }
        state.tensorboardUrl = url;
        el.tbNote.textContent = note;
        el.tbSection.hidden = false;
      }

      async function startTensorboard() {
        if (!el.tbStart) return;
        const originalText = el.tbStart.textContent;
        el.tbStart.disabled = true;
        el.tbStart.textContent = 'Starting...';
        el.tbNote.textContent = 'Starting TensorBoard...';
        try {
          const data = await fetchJson(`${state.apiBase}/tensorboard/start`);
          const message = pick(data, 'message') || (pick(data, 'alreadyRunning') ? 'TensorBoard already running.' : 'TensorBoard started.');
          const url = pick(data, 'url') || defaultTensorboardUrl;
          if (url) {
            const current = el.tbFrame.getAttribute('src');
            if (current !== url) {
              el.tbFrame.setAttribute('src', url);
            }
            el.tbSection.hidden = false;
          }
          el.tbNote.textContent = message;
          await refreshAll();
        } catch (err) {
          console.error(err);
          el.tbNote.textContent = err?.message || 'Failed to start TensorBoard.';
        } finally {
          el.tbStart.disabled = false;
          el.tbStart.textContent = originalText;
        }
      }

      function setCounts(runs) {
        const summary = runs.reduce((acc, run) => {
          const status = (pick(run, 'status') || '').toLowerCase();
          if (status === 'running') acc.running += 1;
          if (status === 'failed' || status === 'failure') acc.failed += 1;
          if (pick(run, 'completed')) acc.completed += 1;
          return acc;
        }, { running: 0, completed: 0, failed: 0 });
        el.runningCount.textContent = summary.running;
        el.completedCount.textContent = summary.completed;
        el.failedCount.textContent = summary.failed;
      }

      function pruneSelection(validRunIds) {
        const valid = new Set(validRunIds);
        state.hiddenRuns = new Set([...state.hiddenRuns].filter(id => valid.has(id)));
      }

      function updateSelectionChip() {
        const total = state.lastRuns.length;
        const hidden = state.hiddenRuns.size;
        const visible = Math.max(0, total - hidden);
        el.selectionChip.textContent = `${visible} of ${total} showing details`;
      }

      function updateKillOptions(knownList) {
        const select = el.killSelect;
        const previous = select.value;
        const options = ['mlagents-learn.exe', 'tensorboard', ...new Set(Array.isArray(knownList) ? knownList : [])];
        select.innerHTML = '<option value="">Select executable</option>';
        options.forEach(name => {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          select.append(opt);
        });
        if (previous && options.includes(previous)) {
          select.value = previous;
        }
      }

      function renderProcessStatus(status, errorMessage) {
        const data = status || {};
        const resultsDir = pick(data, 'resultsDirectory') || 'Unknown results dir';
        const processError = errorMessage || null;
        el.processNote.textContent = processError ?? `Results dir: ${resultsDir}`;

        const count = Number(pick(data, 'mlagentsLearnProcesses') ?? 0);
        const safeCount = Number.isFinite(count) ? count : 0;
        el.mlagentsNote.textContent = `${safeCount === 1 ? 'process' : 'processes'} running`;

        if (processError) {
          el.mlagentsTableBody.innerHTML = `<tr><td colspan="3" class="muted">Process info unavailable.</td></tr>`;
          el.envTableBody.innerHTML = `<tr><td colspan="3" class="muted">Process info unavailable.</td></tr>`;
          el.envNote.textContent = 'Refresh or verify the API to restore process visibility.';
          state.knownEnvExecutables = [];
          updateKillOptions(state.knownEnvExecutables);
          return;
        }

        el.mlagentsTableBody.innerHTML = '';
        const mlRow = document.createElement('tr');
        mlRow.innerHTML = `
          <td>mlagents-learn.exe</td>
          <td><span class="badge ${safeCount > 0 ? 'success' : 'idle'}"><span class="badge-dot"></span>${safeCount > 0 ? 'Running' : 'Idle'}</span></td>
          <td>${safeCount}</td>
        `;
        el.mlagentsTableBody.append(mlRow);

        const running = (() => {
          const value = pick(data, 'runningEnvExecutables');
          return Array.isArray(value) ? value.filter(Boolean) : [];
        })();
        const runningDetails = (() => {
          const value = pick(data, 'runningEnvProcesses');
          if (!Array.isArray(value)) {
            return [];
          }
          return value
            .map(item => {
              const executable = pick(item, 'executable') || pick(item, 'Executable');
              const countValue = Number(pick(item, 'count') ?? pick(item, 'Count') ?? 0);
              const safeCount = Number.isFinite(countValue) && countValue > 0 ? countValue : 0;
              return executable ? { executable, count: safeCount } : null;
            })
            .filter(Boolean);
        })();
        const runningCountByName = new Map(runningDetails.map(item => [item.executable, item.count]));
        const totalRunningEnvProcesses = runningDetails.reduce((sum, item) => sum + item.count, 0);
        const known = (() => {
          const value = pick(data, 'knownEnvExecutables');
          return Array.isArray(value) ? value.filter(Boolean) : [];
        })();

        const merged = Array.from(new Set([...known, ...running])).filter(Boolean);
        state.knownEnvExecutables = known;
        updateKillOptions(state.knownEnvExecutables);

        el.envTableBody.innerHTML = '';
        if (!merged.length) {
          el.envTableBody.innerHTML = `<tr><td colspan="3" class="muted">No env executables discovered yet.</td></tr>`;
        } else {
          merged.sort((a, b) => a.localeCompare(b));
          merged.forEach(name => {
            const runningCount = runningCountByName.get(name) ?? 0;
            const isRunning = runningCount > 0;
            const row = document.createElement('tr');
            row.innerHTML = `
              <td>${name}</td>
              <td><span class="badge ${isRunning ? 'success' : 'idle'}"><span class="badge-dot"></span>${isRunning ? 'Running' : 'Idle'}</span></td>
              <td>${runningCount}</td>
            `;
            el.envTableBody.append(row);
          });
        }

        if (known.length) {
          const runningSuffix = totalRunningEnvProcesses > 0 ? `, ${totalRunningEnvProcesses} running process${totalRunningEnvProcesses === 1 ? '' : 'es'}` : ', none running';
          el.envNote.textContent = `Tracking ${known.length} env exe${known.length === 1 ? '' : 's'} from results folders${runningSuffix}.`;
        } else {
          el.envNote.textContent = 'No env executables discovered in results folders yet.';
        }
      }

      async function updateProcessStatus() {
        try {
          const data = await fetchJson(`${state.apiBase}/process-status`);
          renderProcessStatus(data);
        } catch (err) {
          console.error(err);
          renderProcessStatus(null, 'Unable to load process info.');
          throw err;
        }
      }

      async function killSelectedExecutable() {
        const executable = el.killSelect.value;
        if (!executable) {
          el.killNote.textContent = 'Pick an executable to kill.';
          return;
        }
        el.killBtn.disabled = true;
        el.killBtn.textContent = 'Killing...';
        try {
          const result = await postJson(`${state.apiBase}/process-kill`, { executable });
          const matched = Number(pick(result, 'matchedProcesses') ?? 0);
          const killed = Number(pick(result, 'killedProcesses') ?? 0);
          const errors = Array.isArray(result?.errors) ? result.errors.filter(Boolean) : [];
          if (errors.length) {
            el.killNote.textContent = `${executable}: matched ${matched}, killed ${killed}. Errors: ${errors.join(' | ')}`;
          } else {
            el.killNote.textContent = `${executable}: matched ${matched}, killed ${killed}.`;
          }
          await updateProcessStatus();
        } catch (err) {
          console.error(err);
          el.killNote.textContent = err?.message || 'Failed to kill processes.';
        } finally {
          el.killBtn.disabled = false;
          el.killBtn.textContent = 'Kill all';
        }
      }

      async function refreshAll() {
        const healthPromise = updateHealth();
        const processPromise = updateProcessStatus().catch(() => {});
        try {
          const runs = await fetchJson(`${state.apiBase}/train-status`);
          renderRuns(runs);
          await refreshLogs(runs);
        } catch (err) {
          console.error(err);
          renderRuns([], 'Unable to load runs.');
        }
        await Promise.all([healthPromise, processPromise]);
        const now = new Date();
        el.updatedLabel.textContent = now.toLocaleTimeString();
        state.forceTensorboardReload = false;
      }

      function scheduleNextRefresh() {
        if (state.refreshHandle) {
          clearTimeout(state.refreshHandle);
        }
        state.nextRefreshAt = Date.now() + state.refreshMs;
        updateRefreshLabel();
        state.refreshHandle = setTimeout(async () => {
          await refreshAll();
          scheduleNextRefresh();
        }, state.refreshMs);
      }

      function startLoop() {
        if (state.refreshHandle) {
          clearTimeout(state.refreshHandle);
        }
        if (state.tickerHandle) {
          clearInterval(state.tickerHandle);
        }
        state.nextRefreshAt = Date.now() + state.refreshMs;
        startTicker();
        refreshAll();
        state.refreshHandle = setTimeout(async () => {
          await refreshAll();
          scheduleNextRefresh();
        }, state.refreshMs);
      }

      el.refreshBtn.addEventListener('click', async () => {
        state.forceTensorboardReload = true;
        await refreshAll();
        scheduleNextRefresh();
        state.forceTensorboardReload = false;
      });
      el.refreshSlider.addEventListener('input', (event) => {
        setRefreshMs(event.target.value);
      });
      el.embedHeightSlider.addEventListener('input', (event) => {
        setEmbedHeight(event.target.value);
      });
      el.logHeightSlider.addEventListener('input', (event) => {
        setLogHeight(event.target.value);
      });
      el.setApiBtn.addEventListener('click', () => {
        setApiBase(el.apiInput.value);
        refreshAll();
        scheduleNextRefresh();
      });
      el.tbStart?.addEventListener('click', startTensorboard);
      el.killBtn.addEventListener('click', killSelectedExecutable);
      el.clearSelection.addEventListener('click', () => {
        state.hiddenRuns.clear();
        updateSelectionChip();
        document.querySelectorAll('.card').forEach(card => {
          card.classList.remove('collapsed');
          card.classList.add('selected');
          const details = card.querySelector('.card-details');
          if (details) details.hidden = false;
        });
        document.querySelectorAll('.card input[type="checkbox"]').forEach(cb => { cb.checked = true; });
      });
      startLoop();
    })();
  </script>
</body>
</html>


